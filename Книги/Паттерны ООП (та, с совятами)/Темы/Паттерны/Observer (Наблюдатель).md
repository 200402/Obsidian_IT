# Наблюдатель (Observer)
## Задача
- Система состоит из множества [[Класс]]ов, [[Объект]]ы которых должны находиться в согласованных состояниях
- Общая схема взаимодействия [[Объект]]ов предполагает две стороны: одна рассылает сообщения и является главным, другая получает сообщения и реагирует на них. Отделение логики обеих сторон позволяет их рассматривать независимо и использовать отдельно друга от друга.
- Существует один [[Объект]], рассылающий сообщения, и множество подписчиков, которые получают сообщения. При этом точное число подписчиков заранее неизвестно и процессе работы программы может изменяться.

## Решение

```C#
interface IObservable
{
    void AddObserver(IObserver o);
    void RemoveObserver(IObserver o);
    void NotifyObservers();
}
class ConcreteObservable : IObservable
{
    private List<IObserver> observers;
    public ConcreteObservable()
    {
        observers = new List<IObserver>();
    }
    public void AddObserver(IObserver o)
    {
        observers.Add(o);
    }
 
    public void RemoveObserver(IObserver o)
    {
        observers.Remove(o);
    }
 
    public void NotifyObservers()
    {
        foreach (IObserver observer in observers)
            observer.Update();
    }
}
 
interface IObserver
{
    void Update();
}
class ConcreteObserver :IObserver
{
    public void Update()
    {
    }
}
```

## Результаты
### Плюсы
- **Более удобный в обслуживании код** за счет меньшей степени зацепления между наблюдаемыми классами и их зависимостями (наблюдателями).
- **Чистый код.** Гарантируется соблюдение принципа открытости/закрытости, поскольку можно добавлять новых наблюдателей (подписчиков) без нарушения существующего кода наблюдаемых объектов и наоборот.
- **Более понятный код.** Соблюдается принцип единственной ответственности (SRP): вместо того, чтобы размещать бизнес-логику в объекте `Observable`, ответственность каждого наблюдателя передается его методу `update`.

### Минусы
- Усложнение кода и увеличение числа классов, которые в нем (наблюдателе) нуждаются.

#Паттерн